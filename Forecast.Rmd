---
title: "Dynamic models of interaction betadiversity"
output:
html_document:
  toc: true
  number_sections: true
  theme: spacelab
  keep_md: true
editor_options: 
chunk_output_type: console
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(chron)
library(dplyr)
library(ggplot2)
library(reshape2)
library(knitr)
library(R2jags)
library(dplyr)
library(stringr)
library(gridExtra)
library(boot)
library(foreach)
library(bipartite)
library(tidyr)
library(doSNOW)
library(betalink)
library(igraph)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=10,fig.height=7,echo=F,cache=F,fig.align='center',fig.path="figureObserved/")

#source functions
source("models/Functions.R")

newModel<-T
```

```{r,echo=F,cache=FALSE}
paste("Run Completed at",Sys.time())
```

```{r}
#reload if needed
#load("ObservedModel.RData")
```

```{r}
#Load data
#read in flower morphology data, comes from Nectar.R
fl.morph<-read.csv("data/FlowerMorphology.csv")

#use effective corolla where possible.
fl.morph$Corolla<-fl.morph$EffectiveCorolla

fl.morph[is.na(fl.morph$Corolla),"Corolla"]<-fl.morph[is.na(fl.morph$Corolla),"TotalCorolla"]

#First row is empty
fl.morph<-fl.morph[-1,]

#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv("data/HummingbirdMorphology.csv")

#taxonomy change, we are calling them Crowned Woodnymph's now.
hum.morph$English<-as.character(hum.morph$English)

hum.morph$English[hum.morph$English %in% "Green-crowned Woodnymph"]<-"Crowned Woodnymph"

#Bring in Interaction Matrix
int<-read.csv("data/HummingbirdInteractions.csv")

int$timestamp<-as.POSIXct(paste(int$Time,int$DateP),format="%H:%M:%S %Y-%m-%d")

#one date error
int[int$DateP %in% '2013-07-25',"Month"]<-7

#one duplicate camera error, perhaps two GPS records.
int<-int[!(int$ID %in% "FH1108" & int$Date_F %in% '2014-12-01'),]

#Correct known taxonomic disagreements, atleast compared to traits
int[int$Iplant_Double %in% "Onagaraceae fuschia","Iplant_Double"]<-"Fuchsia macrostigma"
int[int$Iplant_Double=="Alloplectus purpureus","Iplant_Double"]<-"Glossoloma purpureum"
int[int$Iplant_Double=="Capanea affinis","Iplant_Double"]<-"Kohleria affinis"
int[int$Iplant_Double=="Columnea cinerea","Iplant_Double"]<-"Columnea mastersonii"
int[int$Iplant_Double=="Alloplectus teuscheri","Iplant_Double"]<-"Drymonia teuscheri"
int[int$Iplant_Double=="Drymonia collegarum","Iplant_Double"]<-"Alloplectus tetragonoides"

#Some reasonable level of presences, 4 points
keep<-names(which(table(int$Hummingbird) > 4))

#int<-int[int$Hummingbird %in% keep & !int$Hummingbird %in% c("Sparkling Violetear"),]

m.dat<-droplevels(int[colnames(int) %in% c("ID","Video","Time","Hummingbird","Sex","timestamp","TransectID","Transect_R","Iplant_Double","Pierce","DateP","Month","ele","Type")])

#Does the data come from camera or transect?
m.dat$Type<-(is.na(m.dat$TransectID))*1

m.dat$Year<-years(as.Date(m.dat$DateP))

#one missing date
m.dat$Year[m.dat$Year %in% 2012]<-2013
m.dat$Year[m.dat$Year %in% 2106]<-2016

#Number of bird species
h_species<-nlevels(m.dat$Hummingbird)

#Number of plant species
plant_species<-nlevels(m.dat$Iplant_Double)

#Get english name
dath<-merge(m.dat,hum.morph, by.x="Hummingbird",by.y="English",keep=all)

#Merge to flowers
int.FLlevels<-levels(factor(dath$Iplant_Double))

#Which flowers are we missing info for?
missingTraits<-int.FLlevels[!int.FLlevels %in% fl.morph$X]

#print(paste("Missing Trait Information:",missingTraits))
dath<-merge(dath,fl.morph, by.x="Iplant_Double",by.y="X")

#Drop piercing events, since they don't represent correlation
#dath<-dath[!dath$Pierce %in% c("y","Y"),]
```

```{r}
##Match Species to Morphology
#observed traitmatching
traitmatchF<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$Corolla})))
rownames(traitmatchF)<-hum.morph$English
colnames(traitmatchF)<-fl.morph$Group.1
```

```{r}
#match names #Round to 2 decimals #Convert to cm for winbugs, avoids numerical underflow
traitmatchT<-round(traitmatchF[rownames(traitmatchF) %in% dath$Hummingbird,colnames(traitmatchF) %in% dath$Iplant_Double],2)
traitmatchT<-traitmatchT[sort(rownames(traitmatchT)),sort(colnames(traitmatchT))]
```


```{r}
##Elevation ranges

elevH<-read.csv("data/HummingbirdElevation.csv",row.names=1)
head(elevH)
colnames(elevH)[5]<-"Elevation"
elevH$Bird<-1:nrow(elevH)

#high elevation or low elevation
elevP<-read.csv("data/PlantElevation.csv",row.names=1)
colnames(elevP)[5]<-"Elevation"
elevP$Plant<-1:nrow(elevP)
elevP$Iplant_Double<-as.character(elevP$Iplant_Double)

#Merge to observed data
#plants
dathp<-merge(dath,elevP,by="Iplant_Double")

#birds
datph<-merge(dathp,elevH,by="Hummingbird")
```


```{r}
#What elevation transect is each observation in?
#The camera data need to be inferred from the GPS point.

#cut working best on data.frame
datph<-as.data.frame(datph)

#which elevation bin is each observation within
labs<-paste(seq(1300,2500,200),seq(1500,2700,200),sep="_")

#for the couple points that have 1290 elevation, round up to 300 for convienance
datph$ele[datph$ele < 1300]<-1301
datph$ele<-as.numeric(datph$ele)
datph$Transect_R[is.na(datph$Transect_R)]<-as.character(cut(datph[is.na(datph$Transect_R),]$ele,seq(1300,2700,200),labels=labs))

#Elev for the transects is the midpoint
tran_elev<-datph[datph$Survey_Type=='Transect',"Transect_R"]
datph[datph$Survey_Type=='Transect',"ele"]<-sapply(tran_elev,function(x){
mean(as.numeric(str_split(x,"_")[[1]]))
})
```


```{r}
### Define Time Events
#ID for NA is holger transects, make the id's 1:n for each day of transect at each elevation, assuming no elevation was split across days.
datph$ID<-as.character(datph$ID)
noid<-datph[is.na(datph$ID),]

id_topaste<-paste(noid$Month,noid$Year,"Transect",sep="_")
datph[which(is.na(datph$ID)),"ID"]<-id_topaste

#Create year month combination
datph$Time<-paste(datph$Month,datph$Year,sep="_")

#Label survey type
datph$Survey_Type<-NA

mt<-!is.na(datph$TransectID)*1
datph$Survey_Type[mt==1]<-"Transect"
datph$Survey_Type[!datph$Survey_Type %in% "Transect"]<-"Camera"

datph<-datph[datph$Survey_Type=="Camera",]

#time filter

#sort by timestamp
datph<-datph[order(datph$timestamp),]

dotime<-function(d){
  d$Timediff<-NA
  if(nrow(d)>1){
    for (x in 2:nrow(d)){
    d$Timediff[x]<-difftime(d$timestamp[x],d$timestamp[x-1],units="mins")  
  }
}
  return(d)
}

datph<-datph %>% group_by(ID,Hummingbird) %>% do(dotime(.))

#eliminate interaction by the same species within five minutes
datph<-datph[!1:nrow(datph) %in% which(datph$Timediff<5),]
#Day level
#add day ID
sdat<-split(datph,list(datph$ID),drop = T)

sdat<-lapply(sdat,function(x){
x<-droplevels(x)
x$Day<-as.numeric(as.factor(x$DateP))
return(x)
})

indatraw<-rbind_all(sdat)

#Species names
for (x in 1:nrow(indatraw)){
  indatraw$Hummingbird[x]<-as.character(elevH[elevH$Bird %in% indatraw$Bird[x],"Hummingbird"])
  indatraw$Iplant_Double[x]<-as.character(elevP[elevP$Plant %in% indatraw$Plant[x],"Iplant_Double"])
}

#match the traits
traitmelt<-melt(traitmatchT)
colnames(traitmelt)<-c("Hummingbird","Iplant_Double","Traitmatch")

#dummy presence variable
indatraw$Yobs<-1

#prune columns to make more readable
indatraw<-indatraw[,c("Hummingbird","Iplant_Double","ID","Time","Month","Year","Transect_R","ele","DateP","Yobs","Day","Survey_Type","Pierce")]
```


```{r}
##Summarize daily interactions
indatraw<-indatraw %>% group_by(Hummingbird,Iplant_Double,ID,Day) %>% summarize(Yobs=sum(Yobs),Time=unique(Time),Transect_R=unique(Transect_R),Month=unique(Month),Year=unique(Year),ele=mean(ele),DateP=unique(DateP),Survey_Type=unique(Survey_Type)) %>% ungroup()
```

#Static betadiversity
```{r}

```

```{r}
indat<-prepData(indatraw)
```

#Modeling Fitting

```{r}
models<-list()
chains<-list()
networks<-list()
```

## Random Baseline

```{r}
#Cut into slices
#Cut data into timeslices
indat<-indat %>% arrange(DateP)
indat$interval<-cut(as.POSIXct(indat$DateP),2)
indat$jinterval<-as.numeric(indat$interval)
intervals<-unique(indat$jinterval)

#For species identity, there can't be any species interactions not in the prediction dataset.
obs_levels<-indat %>% filter(jinterval==1) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

predict_levels<-indat %>% filter(jinterval==2) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

missing<-predict_levels[!predict_levels %in% obs_levels]
species_dat<-indat %>% filter(!paste(Hummingbird,Iplant_Double,sep="_") %in% missing) %>% droplevels()

#if those missing interactions eliminate a species overall
#Easiest to work with jags as numeric ordinal values
species_dat$Hummingbird<-as.factor(species_dat$Hummingbird)
species_dat$Iplant_Double<-as.factor(species_dat$Iplant_Double)
species_dat$jBird<-as.numeric(species_dat$Hummingbird)
species_dat$jPlant<-as.numeric(species_dat$Iplant_Double)

jagsIndexBird<-data.frame(Hummingbird=levels(species_dat$Hummingbird),jBird=1:length(levels(species_dat$Hummingbird)))

jagsIndexPlants<-data.frame(Iplant_Double=levels(species_dat$Iplant_Double),jPlant=1:length(levels(species_dat$Iplant_Double)))

#Similiarly, the trait matrix needs to reflect this indexing.
jTraitmatch<-traitmatchT[rownames(traitmatchT) %in% unique(species_dat$Hummingbird),colnames(traitmatchT) %in% unique(species_dat$Iplant_Double)]

species_dat$Index<-1:nrow(species_dat)
species_dat<-droplevels(species_dat)

#Turn Time and ID into numeric indexes
species_dat$jTime<-as.numeric(as.factor(species_dat$Time))
species_dat$jID<-as.numeric(as.factor(species_dat$ID))

#Split data
Yobs_dat<-species_dat[species_dat$jinterval <= intervals[1],]
Ynew_dat<-species_dat[species_dat$jinterval > intervals[1],]
```

$$ Yobs_{i,j} \sim Bernoulli(N(0,1.68)) $$


```{r}
#Source model
source("models/SpeciesIdentity.R")

#print model
writeLines(readLines("models/SpeciesIdentity.R"))
```

## Predicted

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    Ynew_pred<-rep(1,Dat$Nnewdata)
    list(Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew")
  
  #Jags Data
  Yobs<-(Yobs_dat$Yobs > 0)*1
  Ynew<-(Ynew_dat$Yobs> 0)*1
  
  Dat<-list(
    Birds=max(Yobs_dat$jBird),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(Yobs_dat$jPlant),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity.jags",n.thin=1,n.iter=2000,n.burnin=1500,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Random<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
  splitpc[c("Ynew_pred")]<-lapply(
    splitpc[c("Ynew_pred")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}
#generate chains
chains$Random<-getChains(models$Random)

##Generate network
networks$Random<-getPredictions(pars=chains$Random,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=8,fig.height=4}
###Chains
chains$Random %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

## Species Identity

```{r}
#Cut into slices
#Cut data into timeslices
indat<-indat %>% arrange(DateP)
indat$interval<-cut(as.POSIXct(indat$DateP),2)
indat$jinterval<-as.numeric(indat$interval)
intervals<-unique(indat$jinterval)

#For species identity, there can't be any species interactions not in the prediction dataset.
obs_levels<-indat %>% filter(jinterval==1) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

predict_levels<-indat %>% filter(jinterval==2) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

missing<-predict_levels[!predict_levels %in% obs_levels]
species_dat<-indat %>% filter(!paste(Hummingbird,Iplant_Double,sep="_") %in% missing) %>% droplevels()

#if those missing interactions eliminate a species overall
#Easiest to work with jags as numeric ordinal values
species_dat$Hummingbird<-as.factor(species_dat$Hummingbird)
species_dat$Iplant_Double<-as.factor(species_dat$Iplant_Double)
species_dat$jBird<-as.numeric(species_dat$Hummingbird)
species_dat$jPlant<-as.numeric(species_dat$Iplant_Double)

jagsIndexBird<-data.frame(Hummingbird=levels(species_dat$Hummingbird),jBird=1:length(levels(species_dat$Hummingbird)))

jagsIndexPlants<-data.frame(Iplant_Double=levels(species_dat$Iplant_Double),jPlant=1:length(levels(species_dat$Iplant_Double)))

#Similiarly, the trait matrix needs to reflect this indexing.
jTraitmatch<-traitmatchT[rownames(traitmatchT) %in% unique(species_dat$Hummingbird),colnames(traitmatchT) %in% unique(species_dat$Iplant_Double)]

species_dat$Index<-1:nrow(species_dat)
species_dat<-droplevels(species_dat)

#Turn Time and ID into numeric indexes
species_dat$jTime<-as.numeric(as.factor(species_dat$Time))
species_dat$jID<-as.numeric(as.factor(species_dat$ID))

#Split data
Yobs_dat<-species_dat[species_dat$jinterval <= intervals[1],]
Ynew_dat<-species_dat[species_dat$jinterval > intervals[1],]
```

$$ Yobs_{i,j} \sim Bernoulli(\lambda_{i,j}) $$

```{r}
#Source model
source("models/SpeciesIdentity.R")

#print model
writeLines(readLines("models/SpeciesIdentity.R"))
```

## Predicted

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    Ynew_pred<-rep(1,Dat$Nnewdata)
    list(Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew","E.new")
  
  #Jags Data
  Yobs<-(Yobs_dat$Yobs > 0)*1
  Ynew<-(Ynew_dat$Yobs> 0)*1
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(Yobs_dat$jBird),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(Yobs_dat$jPlant),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity.jags",n.thin=1,n.iter=2000,n.burnin=1500,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Species<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
  splitpc[c("Ynew_pred")]<-lapply(
    splitpc[c("Ynew_pred")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}

##Generate chains
chains$Species<-getChains(models$Species)

##Generate networks
networks$Species<-getPredictions(chains$Species,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=8,fig.height=5}
###Chains
chains$Species %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

## Detectability + Species

To Do. Should I also do traits without the detection probabilities?

## Detectability + Trait-matching

For hummingbird species i feeding on plant species j observed at time k and sampling event observed by transect 

Observation Model:

$$ Yobs_{i,j,k,d} \sim Binomial(N_{i,j,k},\omega) $$

Process Model:

$$ N_{i,j,k} \sim Binomial(\lambda_{i,j,k}) $$
$$ logit(\lambda_{i,j,k}) = \alpha_i + \beta_{1,i} * Traitmatch_{i,j} $$

```{r}
#Source model
source("models/TraitMatch.R")

#print model
writeLines(readLines("models/TraitMatch.R"))

runModel<-function(Yobs_dat,Ynew_dat,jTraitmatch){
  
  #Inits
  InitStage <- function(){
    #A blank Y matrix - all present
    initY<-rep(1,Dat$Nobs)
    initB<-rep(0.5,Dat$Birds)
    Ynew_pred<-rep(1,Dat$Nnewdata)
    z<-rep(1,Dat$Nobs)
    znew<-rep(1,Dat$Nnewdata)
    
    list(dcam=initB,znew=znew,z=z,Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","beta1","alpha_mu","alpha_sigma","beta1_sigma","beta1_mu","detect","Ynew_pred","fit","fitnew")
  
  #Jags Data
  Yobs<-(Yobs_dat$Yobs > 0)*1
  Ynew<-(Ynew_dat$Yobs> 0)*1
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(Yobs_dat$jBird),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew),
    Traitmatch=jTraitmatch)
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/TraitMatch.jags",n.thin=1,n.iter=2000,n.burnin=1500,n.chains=2,DIC=F)
    )
    return(m2)
}

#Run Model
models$Traits<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat,jTraitmatch=jTraitmatch)
```

```{r}
getChains<-function(x,Bird="Bird",Plant="Plant"){
  #extract desired info from the models
  #bind chains
  pc_dive<-reshape2::melt(x$BUGSoutput$sims.array)
  colnames(pc_dive)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc_dive$parameter<-data.frame(str_match(pc_dive$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc_dive,pc_dive$parameter)
  
  #single index
  splitpc[c("alpha","beta1","detect","Ynew_pred")]<-lapply(splitpc[c("alpha","beta1","detect","Ynew_pred")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    return(pc)
  }) 
  
  #bind all matrices back together
  pc_dive<-bind_rows(splitpc)
}
```

```{r}
#Get Chains
chains$Traits<-getChains(models$Traits,Bird="jBird",Plant="jPlant")

#Get networks
networks$Traits<-getPredictions(chains$Traits,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=13,fig.height=5}
###Chains
ggplot(chains$Traits[chains$Traits$parameter %in% c("alpha_mu","beta1_mu"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~parameter,scale="free") + theme_bw() + labs(col="Chain") 
```

```{r,fig.height=5,fig.width=11}
ggplot(chains$Traits[chains$Traits$par %in% c("beta1_mu","beta1_sigma","alpha_mu","alpha_sigma"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Group Level Parameters") + facet_wrap(~par,scales="free")
```

# Model Comparison

```{r}
#A bit ugly, but let's assign names.
for(x in 1:length(chains)){
    chains[[x]]<-chains[[x]] %>% mutate(Model=names(chains)[x])
  }

allchains<-bind_rows(lapply(chains,bind_rows))

ggplot(allchains[allchains$parameter %in% c("fitnew"),],aes(x=1-value)) + geom_density(aes(fill=Model),alpha=0.5) + theme_bw() + labs(x="Proportion of correctly predicted observations") + scale_x_continuous(labels=scales::percent)
#ggsave("Figures/PredLinksBoth.svg")
#ggsave("Figures/PredLinksBoth.jpeg",height=3,width=7)
```

## Network statistics

```{r}
#Get network statistics for all models.
allnetworks<-lapply(networks,function(x){
    lapply(x,function(y){
      d<-networklevel(y,index=c("connectance","niche overlap"),level="lower")
      return(data.frame(Metric=names(d),value=d))
    })
  })

allnetworks<-melt(allnetworks,id.var=c("Metric","value"))

#Observed binary network
m_new<-acast(Ynew_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)

m_new<-m_new > 0 * 1

obs_net<-networklevel(m_new,index=c("connectance","niche overlap"),level="lower")

obs_net<-melt(data.frame(Metric=names(obs_net),value=obs_net))

#Plot
allnetworks<-allnetworks %>% select(Model=L1,Metric,value)
ggplot(allnetworks,aes(x=value)) + geom_density(aes(fill=Model),alpha=0.5) + facet_wrap(~Metric) + geom_vline(data=obs_net,aes(xintercept=value),linetype="dashed")
```

# Predicted betadiversity
From Poisot 2016 "Network Comparison"

Dissimilairty in interactions(Beta_WN from Poisot 2012)

```{r}
#Observed dissimalarity
m_obs<-acast(Yobs_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)
m_new<-acast(Ynew_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)

#Turn into binary links
m_obs<-m_obs > 0 * 1
m_new<-m_new > 0 * 1

obs_dis<-betalink(graph.incidence(m_obs),graph.incidence(m_new))
```

```{r}
betastat<-lapply(networks,function(x){
  lapply(x,function(y){
    obs_dis<-betalink(graph.incidence(m_obs),graph.incidence(y))
  })
})

betastat<-melt(betastat)
colnames(betastat)<-c("value","Betadiversity","Iteration","Model")
mobs_dis<-melt(obs_dis)
colnames(mobs_dis)<-c("value","Betadiversity")

#recode levels
betastat$Betadiversity<-factor(betastat$Betadiversity)
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "WN"]<-"Interaction Dissimilarity"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "ST"]<-"Interaction Turnover"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "OS"]<-"Interaction Rewiring"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "S"]<-"Species Turnover"

mobs_dis$Betadiversity<-factor(mobs_dis$Betadiversity)
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "WN"]<-"Interaction Dissimilarity"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "ST"]<-"Interaction Turnover"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "OS"]<-"Interaction Rewiring"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "S"]<-"Species Turnover"

ggplot(betastat %>% filter(!Betadiversity %in% "Species Turnover"),aes(x=value,fill=Model)) + geom_density() + facet_wrap(~Betadiversity,scales="free",nrow=1) + geom_vline(data=mobs_dis  %>% filter(!Betadiversity %in% "Species Turnover"),aes(xintercept=value),linetype="dashed")
```

```{r}
# Which interactions were hardest to predict?

#hardest<-allchains %>% group_by(Model) %>% mutate(Enew=abs(Yobs-value)) %>% group_by(jBird,jPlant) %>% arrange(desc(value)) %>% head(5)
```

```{r}
#save.image("ObservedModel.RData")
```