---
title: "Dynamic models of interaction betadiversity"
output:
html_document:
  toc: true
  number_sections: true
  theme: spacelab
  keep_md: true
editor_options: 
chunk_output_type: console
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(chron)
library(dplyr)
library(ggplot2)
library(reshape2)
library(knitr)
library(R2jags)
library(stringr)
library(gridExtra)
library(boot)
library(foreach)
library(bipartite)
library(tidyr)
library(doSNOW)
library(betalink)
library(ggbiplot)
library(igraph)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=10,fig.height=7,echo=F,cache=F,fig.align='center',fig.path="figureObserved/")

#source functions
source("models/Functions.R")

newModel<-T
```

```{r,echo=F,cache=FALSE}
paste("Run Completed at",Sys.time())
```

```{r}
#reload if needed
#load("ObservedModel.RData")
```

```{r}
fulldat<-read.csv("data/fulldat.csv",row.names=1)
fulldat$timestamp<-as.POSIXct(fulldat$timestamp)
```


```{r}
#read in flower morphology data, comes from Nectar.R
fl.morph<-read.csv("data/FlowerMorphology.csv")
missing<-fulldat %>% anti_join(fl.morph)

#remove 
fulldat<-fulldat %>% filter(!Iplant_Double %in% missing$Iplant_Double)

#TraitMatching Matrix
#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv("data/HummingbirdMorphology.csv")

#taxonomy change, we are calling them Crowned Woodnymph's now.
hum.morph$English<-as.character(hum.morph$English)
hum.morph$English[hum.morph$English %in% "Green-crowned Woodnymph"]<-"Crowned Woodnymph"

traitmatch<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$Corolla})))
rownames(traitmatch)<-hum.morph$English
colnames(traitmatch)<-fl.morph$Iplant_Double

traitmatch<-round(traitmatch[rownames(traitmatch) %in% fulldat$Hummingbird,colnames(traitmatch) %in% fulldat$Iplant_Double],2)
traitmatch<-traitmatch[sort(rownames(traitmatch)),sort(colnames(traitmatch))]

##Elevation ranges for reference
elevH<-read.csv("data/HummingbirdElevation.csv",row.names=1)
colnames(elevH)[5]<-"Elevation"
elevH$Bird<-1:nrow(elevH)

#high elevation or low elevation
elevP<-read.csv("data/PlantElevation.csv",row.names=1)
colnames(elevP)[5]<-"Elevation"
elevP$Plant<-1:nrow(elevP)
elevP$Iplant_Double<-as.character(elevP$Iplant_Double)

#Merge to observed data
#plants
dathp<-merge(fulldat,elevP,by="Iplant_Double")

#birds
datph<-merge(fulldat,elevH,by="Hummingbird")
```

```{r}
### Define Time Events

#sort by timestamp
datph<-datph[order(datph$timestamp),]

dotime<-function(d){
  d$Timediff<-NA
  if(nrow(d)>1){
    for (x in 2:nrow(d)){
    d$Timediff[x]<-difftime(d$timestamp[x],d$timestamp[x-1],units="mins")  
  }
}
  return(d)
}

datph<-datph %>% group_by(ID,DateP,Hummingbird) %>% do(dotime(.))

#eliminate interaction by the same species within five minutes
datph<-datph[!1:nrow(datph) %in% which(datph$Timediff<5),]
#Day level
#add day ID
sdat<-split(datph,list(datph$ID),drop = T)

sdat<-lapply(sdat,function(x){
x<-droplevels(x)
x$Day<-as.numeric(as.factor(x$DateP))
return(x)
})

indatraw<-bind_rows(sdat)
```

```{r}

#match the traits
traitmelt<-melt(traitmatch)
colnames(traitmelt)<-c("Hummingbird","Iplant_Double","Traitmatch")

#dummy presence variable
indatraw$Yobs<-1
```

```{r}
##Summarize daily interactions
datday<-indatraw %>%filter(!is.na(ele)) %>% mutate(interval=cut(timestamp,2)) %>% dplyr::group_by(Hummingbird,Iplant_Double,ID,Day,interval) %>% dplyr::summarize(Yobs=sum(Yobs),ele=mean(ele,na.rm=T),Date=min(format(timestamp,"%m/%d/%Y")))  %>% mutate(Yobs=(Yobs>0)*1) %>% mutate(site=factor(ele>1700)) %>% arrange(Date)

levels(datday$site)<-c("Maquipucuna","Santa Lucia")

rect <- data.frame(xmin=min(as.POSIXct(datday$Date,format="%m/%d/%Y")), xmax=as.POSIXct(unique(datday$interval)[2]), ymin=-Inf, ymax=Inf)

timeplot<-datday %>% group_by(Date) %>% dplyr::summarize(n=sum(Yobs))

ggplot(timeplot,aes(x=strptime(Date,"%m/%d/%Y"),y=as.integer(n))) + geom_line() + geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), fill="red",alpha=0.2,inherit.aes = FALSE) + theme_bw() + scale_x_datetime() + labs(x="Date",y="Observed Interactions") + scale_y_continuous(breaks=scales::pretty_breaks())
```

```{r}
#Assign site
#Species list at each site
species_list<-datday %>% group_by(site) %>% distinct(Hummingbird) %>% split(.,.$site)
```

#Absence data

```{r}
#For each observation, fill matrix with other species at the site

fill_species<-function(x){
  original<-x
  to_fill<-species_list[[x$site]]$Hummingbird[!species_list[[x$site]]$Hummingbird %in% x$Hummingbird]
  to_return<-list()
  for(s in 1:length(to_fill)){
    x$Hummingbird<-to_fill[s]
    x$Yobs<-0
    to_return[[s]]<-x
  }
  return(bind_rows(original,to_return))
}

indat<-datday %>% ungroup() %>% mutate(Index=1:nrow(.)) %>% group_by(Index) %>% do(fill_species(.)) %>% select(-Index)
```

#Models

```{r}
models<-list()
chains<-list()
networks<-list()
```

## Random Baseline

```{r}

indat$jinterval<-as.numeric(indat$interval)

#For species identity, there can't be any species interactions not in the prediction dataset.
obs_levels<-indat %>% filter(jinterval==1) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

predict_levels<-indat %>% filter(jinterval==2) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

missing<-predict_levels[!predict_levels %in% obs_levels]
species_dat<-indat %>% filter(!paste(Hummingbird,Iplant_Double,sep="_") %in% missing) %>% droplevels()

#if those missing interactions eliminate a species overall
#Easiest to work with jags as numeric ordinal values
species_dat$Hummingbird<-as.factor(species_dat$Hummingbird)
species_dat$Iplant_Double<-as.factor(species_dat$Iplant_Double)
species_dat$jBird<-as.numeric(species_dat$Hummingbird)
species_dat$jPlant<-as.numeric(species_dat$Iplant_Double)
indat$jinterval<-as.numeric(indat$interval)

jagsIndexBird<-data.frame(Hummingbird=levels(species_dat$Hummingbird),jBird=1:length(levels(species_dat$Hummingbird)))

jagsIndexPlants<-data.frame(Iplant_Double=levels(species_dat$Iplant_Double),jPlant=1:length(levels(species_dat$Iplant_Double)))

#Similiarly, the trait matrix needs to reflect this indexing.
jTraitmatch<-traitmatch[rownames(traitmatch) %in% unique(species_dat$Hummingbird),colnames(traitmatch) %in% unique(species_dat$Iplant_Double)]

species_dat$Index<-1:nrow(species_dat)
species_dat<-droplevels(species_dat)

#Turn Time and ID into numeric indexes
species_dat$jTime<-as.numeric(as.factor(species_dat$Date))
species_dat$jID<-as.numeric(as.factor(species_dat$ID))

#Split data
split_dat<-split(species_dat,species_dat$interval)
Yobs_dat<-split_dat[[1]]
Ynew_dat<-split_dat[[2]]
```

$$ Yobs_{i,j} \sim Bernoulli(N(0,1.68)) $$

```{r}
#Source model
source("models/SpeciesIdentity.R")

#print model
writeLines(readLines("models/SpeciesIdentity.R"))
```

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    Ynew_pred<-rep(1,Dat$Nnewdata)
    list(Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew","Enew")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Birds=max(Yobs_dat$jBird),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(Yobs_dat$jPlant),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity.jags",n.thin=1,n.iter=5000,n.burnin=4500,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Random<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
  splitpc[c("Ynew_pred","Enew")]<-lapply(
    splitpc[c("Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}
#generate chains
chains$Random<-getChains(models$Random)

##Generate network
networks$Random<-getPredictions(pars=chains$Random,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=5,fig.height=2}
###Chains
chains$Random %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

## Species Identity

```{r}
#Cut into slices
intervals<-unique(indat$jinterval)

#For species identity, there can't be any species interactions not in the prediction dataset.
obs_levels<-indat %>% filter(jinterval==1) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

predict_levels<-indat %>% filter(jinterval==2) %>% distinct(Hummingbird,Iplant_Double) %>% mutate(i=paste(Hummingbird,Iplant_Double,sep="_")) %>% .$i

missing<-predict_levels[!predict_levels %in% obs_levels]
species_dat<-indat %>% filter(!paste(Hummingbird,Iplant_Double,sep="_") %in% missing) %>% droplevels()

#if those missing interactions eliminate a species overall
#Easiest to work with jags as numeric ordinal values
species_dat$Hummingbird<-as.factor(species_dat$Hummingbird)
species_dat$Iplant_Double<-as.factor(species_dat$Iplant_Double)
species_dat$jBird<-as.numeric(species_dat$Hummingbird)
species_dat$jPlant<-as.numeric(species_dat$Iplant_Double)

jagsIndexBird<-data.frame(Hummingbird=levels(species_dat$Hummingbird),jBird=1:length(levels(species_dat$Hummingbird)))

jagsIndexPlants<-data.frame(Iplant_Double=levels(species_dat$Iplant_Double),jPlant=1:length(levels(species_dat$Iplant_Double)))

#Similiarly, the trait matrix needs to reflect this indexing.
jTraitmatch<-traitmatch[rownames(traitmatch) %in% unique(species_dat$Hummingbird),colnames(traitmatch) %in% unique(species_dat$Iplant_Double)]

species_dat$Index<-1:nrow(species_dat)
species_dat<-droplevels(species_dat)

#Turn Time and ID into numeric indexes
species_dat$jTime<-as.numeric(as.factor(species_dat$Date))
species_dat$jID<-as.numeric(as.factor(species_dat$ID))

#Split data
split_dat<-split(species_dat,species_dat$interval)
Yobs_dat<-split_dat[[1]]
Ynew_dat<-split_dat[[2]]
```

$$ Yobs_{i,j} \sim Bernoulli(\lambda_{i,j}) $$

```{r}
#Source model
source("models/SpeciesIdentity.R")

#print model
writeLines(readLines("models/SpeciesIdentity.R"))
```

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    Ynew_pred<-rep(1,Dat$Nnewdata)
    list(Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew","Enew")
  
  #Jags Data
  Yobs<-(Yobs_dat$Yobs > 0)*1
  Ynew<-(Ynew_dat$Yobs> 0)*1
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(Yobs_dat$jBird),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(Yobs_dat$jPlant),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity.jags",n.thin=1,n.iter=5000,n.burnin=4500,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Species<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
  splitpc[c("Ynew_pred","Enew")]<-lapply(
    splitpc[c("Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}

##Generate chains
chains$Species<-getChains(models$Species)

##Generate networks
networks$Species<-getPredictions(chains$Species,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=5,fig.height=2}
###Chains
chains$Species %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

## Detectability + Species

To Do. Should I also do traits without the detection probabilities?

## Detectability + Trait-matching

For hummingbird species i feeding on plant species j observed at time k and sampling event observed by transect 

Observation Model:

$$ Yobs_{i,j,k,d} \sim Binomial(N_{i,j,k},\omega) $$

Process Model:

$$ N_{i,j,k} \sim Binomial(\lambda_{i,j,k}) $$
$$ logit(\lambda_{i,j,k}) = \alpha_i + \beta_{1,i} * Traitmatch_{i,j} $$

```{r}
#Source model
source("models/TraitMatch.R")

#print model
writeLines(readLines("models/TraitMatch.R"))

runModel<-function(Yobs_dat,Ynew_dat,jTraitmatch){
  
  #Inits
  InitStage <- function(){
    #A blank Y matrix - all present
    initY<-rep(1,Dat$Nobs)
    initB<-rep(0.5,Dat$Birds)
    Ynew_pred<-rep(1,Dat$Nnewdata)
    z<-rep(1,Dat$Nobs)
    znew<-rep(1,Dat$Nnewdata)
    
    list(dcam=initB,znew=znew,z=z,Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","beta1","alpha_mu","alpha_sigma","beta1_sigma","beta1_mu","detect","Ynew_pred","fit","fitnew","Enew")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(Yobs_dat$jBird),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew),
    Traitmatch=jTraitmatch)
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/TraitMatch.jags",n.thin=1,n.iter=5000,n.burnin=4500,n.chains=2,DIC=F)
    )
    return(m2)
}

#Run Model
models$Traits<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat,jTraitmatch=jTraitmatch)
```

```{r}
getChains<-function(x,Bird="Bird",Plant="Plant"){
  #extract desired info from the models
  #bind chains
  pc_dive<-reshape2::melt(x$BUGSoutput$sims.array)
  colnames(pc_dive)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc_dive$parameter<-data.frame(str_match(pc_dive$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc_dive,pc_dive$parameter)
  
  #single index
  splitpc[c("alpha","beta1","detect","Ynew_pred","Enew")]<-lapply(splitpc[c("alpha","beta1","detect","Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    return(pc)
  }) 
  
  #bind all matrices back together
  pc_dive<-bind_rows(splitpc)
}
```

```{r}
#Get Chains
chains$Traits<-getChains(models$Traits,Bird="jBird",Plant="jPlant")

#Get networks
networks$Traits<-getPredictions(chains$Traits,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=13,fig.height=5}
###Chains
ggplot(chains$Traits[chains$Traits$parameter %in% c("alpha_mu","beta1_mu"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~parameter,scale="free") + theme_bw() + labs(col="Chain") 
```

```{r,fig.height=5,fig.width=11}
ggplot(chains$Traits[chains$Traits$par %in% c("beta1_mu","beta1_sigma","alpha_mu","alpha_sigma"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Group Level Parameters") + facet_wrap(~par,scales="free")
```

## Abundance 

Using the counts from the transects. Abundance is especially important to model, since its fluctuating all the time.

# Model Comparison

```{r}
#A bit ugly, but let's assign names.
for(x in 1:length(chains)){
    chains[[x]]<-chains[[x]] %>% mutate(Model=names(chains)[x])
  }

allchains<-bind_rows(lapply(chains,bind_rows))

ggplot(allchains[allchains$parameter %in% c("fitnew"),],aes(x=1-value)) + geom_density(aes(fill=Model),alpha=0.5) + theme_bw() + labs(x="Proportion of correctly predicted observations") + scale_x_continuous(labels=scales::percent)
#ggsave("Figures/PredLinksBoth.svg")
#ggsave("Figures/PredLinksBoth.jpeg",height=3,width=7)
```

## Predicted network statistics

Dashed line is the observed network from the time-series.

```{r}
#Get network statistics for all models.
allnetworks<-lapply(networks,function(x){
    lapply(x,function(y){
      d<-networklevel(y,index=c("connectance","niche overlap"),level="lower")
      return(data.frame(Metric=names(d),value=d))
    })
  })

allnetworks<-melt(allnetworks,id.var=c("Metric","value"))

#Observed binary network
m_new<-acast(Ynew_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)

m_new<-m_new > 0 * 1

obs_net<-networklevel(m_new,index=c("connectance","niche overlap"),level="lower")

obs_net<-melt(data.frame(Metric=names(obs_net),value=obs_net))

#Plot
allnetworks<-allnetworks %>% select(Model=L1,Metric,value)
ggplot(allnetworks,aes(x=value)) + geom_density(aes(fill=Model),alpha=0.5) + facet_wrap(~Metric) + geom_vline(data=obs_net,aes(xintercept=value),linetype="dashed")
```

# Predicted betadiversity

Dissimilairty in interactions (Beta_WN from Poisot 2012)

Dashed line is the observed network from the time-series.

```{r}
#Observed dissimalarity
m_obs<-acast(Yobs_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)
m_new<-acast(Ynew_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)

#Turn into binary links
m_obs<-m_obs > 0 * 1
m_new<-m_new > 0 * 1

obs_dis<-betalink(graph.incidence(m_obs),graph.incidence(m_new))
```

```{r}
betastat<-lapply(networks,function(x){
  lapply(x,function(y){
    obs_dis<-betalink(graph.incidence(m_obs),graph.incidence(y))
  })
})

betastat<-melt(betastat)
colnames(betastat)<-c("value","Betadiversity","Iteration","Model")
mobs_dis<-melt(obs_dis)
colnames(mobs_dis)<-c("value","Betadiversity")

#recode levels
betastat$Betadiversity<-factor(betastat$Betadiversity)
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "WN"]<-"Interaction Dissimilarity"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "ST"]<-"Interaction Turnover"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "OS"]<-"Interaction Rewiring"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "S"]<-"Species Turnover"

mobs_dis$Betadiversity<-factor(mobs_dis$Betadiversity)
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "WN"]<-"Interaction Dissimilarity"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "ST"]<-"Interaction Turnover"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "OS"]<-"Interaction Rewiring"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "S"]<-"Species Turnover"

ggplot(betastat %>% filter(!Betadiversity %in% "Species Turnover"),aes(x=value,fill=Model)) + geom_density() + facet_wrap(~Betadiversity,scales="free",nrow=1) + geom_vline(data=mobs_dis  %>% filter(!Betadiversity %in% "Species Turnover"),aes(xintercept=value),linetype="dashed")
```

# Model overlap

Create a kind of venn diagram on PCA of model similarity based on per link discrepency. 

```{r}
Enew<-allchains %>% filter(parameter == "Enew") %>% mutate(Index=as.numeric(as.character(Index)))

worst<-Ynew_dat %>% dplyr::select(-jinterval,-interval) %>% mutate(Index=1:nrow(Ynew_dat)) %>% inner_join(Enew,by="Index")%>% dplyr::group_by(Model,Hummingbird,Iplant_Double) %>% dplyr::summarize(mean=mean(-1*value,na.rm=T)) %>% mutate(pair=paste(Hummingbird,Iplant_Double,sep="_")) %>% ungroup() %>% dplyr::select(-Hummingbird,-Iplant_Double) %>% arrange(mean) %>% group_by(Model) %>% top_n(-3,mean) 
worst

Enew<-Ynew_dat %>% dplyr::select(-jinterval,-interval) %>% mutate(Index=1:nrow(Ynew_dat)) %>% inner_join(Enew,by="Index")%>% dplyr::group_by(Model,Hummingbird,Iplant_Double) %>% dplyr::summarize(mean=mean(-1*value,na.rm=T)) %>% mutate(pair=paste(Hummingbird,Iplant_Double,sep="_")) %>% ungroup() %>% dplyr::select(-Hummingbird,-Iplant_Double) %>% spread(pair,mean)

modmatrix<-t(Enew[,-1])
colnames(modmatrix)<-Enew[,1]$Model
prmodel<-prcomp(modmatrix,scale=T)

#get best differntial labels, those which exist in the edges of the space
#loadings<-melt(prmodel$x) %>% spread(Var2,value) %>% group_by(Var2) %>% dplyr::summarize(min(value),max(value))

ggbiplot(prmodel,alpha=0.2) + theme_bw()
```

```{r,eval=F}
#ordination of model space
Enew<-allchains %>% filter(parameter == "Enew") %>% mutate(Index=as.numeric(as.character(Index)))

Enew<-Ynew_dat %>% dplyr::select(-jinterval,-interval) %>% mutate(Index=1:nrow(Ynew_dat)) %>% inner_join(Enew,by="Index")%>% dplyr::group_by(Model,Hummingbird,Iplant_Double) %>% mutate(pair=paste(Hummingbird,Iplant_Double,sep="_")) %>% ungroup() %>% dplyr::select(-Hummingbird,-Iplant_Double) %>% select(Model,pair,value) spread(pair,value) 

modmatrix2<-as.matrix(Enew[,-1])
rownames(modmatrix2)<-Enew[,1]$Model
prmodel2<-prcomp(modmatrix2)
ggbiplot(prmodel2)
```

```{r}
save.image("ObservedModel.RData")
```