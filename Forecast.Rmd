---
title: "Dynamic models of interaction betadiversity"
output:
html_document:
  toc: true
  number_sections: true
  theme: spacelab
  keep_md: true
editor_options: 
chunk_output_type: console
---

```{r,warning=FALSE,message=FALSE,echo=FALSE,cache=FALSE}
library(chron)
library(dplyr)
library(ggplot2)
library(reshape2)
library(knitr)
library(R2jags)
library(stringr)
library(gridExtra)
library(boot)
library(foreach)
library(bipartite)
library(tidyr)
library(doSNOW)
library(betalink)
library(ggbiplot)
library(igraph)

opts_chunk$set(message=FALSE,warning=FALSE,fig.width=10,fig.height=7,echo=F,cache=F,fig.align='center',fig.path="figureObserved/")

#source functions
source("models/Functions.R")

newModel<-T
```

```{r,echo=F,cache=FALSE}
paste("Run Completed at",Sys.time())
```

```{r}
#reload if needed
#load("ObservedModel.RData")
```

```{r}
fulldat<-read.csv("data/fulldat.csv",row.names=1)
fulldat$timestamp<-as.POSIXct(fulldat$timestamp)

#Testing
fulldat<-fulldat %>% sample_n(100)
```

```{r}
#read in flower morphology data, comes from Nectar.R
fl.morph<-read.csv("data/FlowerMorphology.csv")
missing<-fulldat %>% anti_join(fl.morph)

#remove 
fulldat<-fulldat %>% filter(!Iplant_Double %in% missing$Iplant_Double)

#TraitMatching Matrix
#Bring in Hummingbird Morphology Dataset, comes from
hum.morph<-read.csv("data/HummingbirdMorphology.csv")

#taxonomy change, we are calling them Crowned Woodnymph's now.
hum.morph$English<-as.character(hum.morph$English)
hum.morph$English[hum.morph$English %in% "Green-crowned Woodnymph"]<-"Crowned Woodnymph"

traitmatch<-abs(t(sapply(hum.morph$Bill,function(x){x-fl.morph$Corolla})))
rownames(traitmatch)<-hum.morph$English
colnames(traitmatch)<-fl.morph$Iplant_Double

traitmatch<-round(traitmatch[rownames(traitmatch) %in% fulldat$Hummingbird,colnames(traitmatch) %in% fulldat$Iplant_Double],2)
traitmatch<-traitmatch[sort(rownames(traitmatch)),sort(colnames(traitmatch))]

##Elevation ranges for reference
elevH<-read.csv("data/HummingbirdElevation.csv",row.names=1)
colnames(elevH)[5]<-"Elevation"
elevH$Bird<-1:nrow(elevH)

#high elevation or low elevation
elevP<-read.csv("data/PlantElevation.csv",row.names=1)
colnames(elevP)[5]<-"Elevation"
elevP$Plant<-1:nrow(elevP)
elevP$Iplant_Double<-as.character(elevP$Iplant_Double)

#Merge to observed data
#plants
dathp<-merge(fulldat,elevP,by="Iplant_Double")

#birds
datph<-merge(fulldat,elevH,by="Hummingbird")
```

```{r}
### Define Time Events

#sort by timestamp
datph<-datph[order(datph$timestamp),]

dotime<-function(d){
  d$Timediff<-NA
  if(nrow(d)>1){
    for (x in 2:nrow(d)){
    d$Timediff[x]<-difftime(d$timestamp[x],d$timestamp[x-1],units="mins")  
  }
}
  return(d)
}

datph<-datph %>% group_by(ID,DateP,Hummingbird) %>% do(dotime(.))

#eliminate interaction by the same species within five minutes
datph<-datph[!1:nrow(datph) %in% which(datph$Timediff<5),]
#Day level
#add day ID
sdat<-split(datph,list(datph$ID),drop = T)

sdat<-lapply(sdat,function(x){
x<-droplevels(x)
x$Day<-as.numeric(as.factor(x$DateP))
return(x)
})

indatraw<-bind_rows(sdat)
```

```{r}

#match the traits
traitmelt<-melt(traitmatch)
colnames(traitmelt)<-c("Hummingbird","Iplant_Double","Traitmatch")

#dummy presence variable
indatraw$Yobs<-1
```

```{r,fig.height=4,fig.width=8}
##Summarize daily interactions
datday<-indatraw %>%filter(!is.na(ele)) %>% mutate(interval=cut(timestamp,2)) %>% dplyr::group_by(Hummingbird,Iplant_Double,ID,Day,interval) %>% dplyr::summarize(Yobs=sum(Yobs),ele=mean(ele,na.rm=T),Date=min(format(timestamp,"%m/%d/%Y")))  %>% mutate(Yobs=(Yobs>0)*1) %>% mutate(site=factor(ele>1700)) %>% arrange(Date)

levels(datday$site)<-c("Maquipucuna","Santa Lucia")

rect <- data.frame(xmin=min(as.POSIXct(datday$Date,format="%m/%d/%Y")), xmax=as.POSIXct(unique(datday$interval)[2]), ymin=-Inf, ymax=Inf)

timeplot<-datday %>% group_by(Date) %>% dplyr::summarize(n=sum(Yobs))

ggplot(timeplot,aes(x=strptime(Date,"%m/%d/%Y"),y=as.integer(n))) + geom_line() + geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), fill="red",alpha=0.2,inherit.aes = FALSE) + theme_bw() + scale_x_datetime() + labs(x="Date",y="Observed Interactions") + scale_y_continuous(breaks=scales::pretty_breaks())
```

```{r}
#Assign site
#Species list at each site
species_list<-datday %>% group_by(site) %>% distinct(Hummingbird)
```

#Absence data

```{r}
#For each observation, fill matrix with other species at the site

fill_species<-function(x){
  original<-x
  to_fill<-species_list$Hummingbird[!species_list$Hummingbird %in% x$Hummingbird]

  to_return<-list()
  for(s in 1:length(to_fill)){
    x$Hummingbird<-to_fill[s]
    x$Yobs<-0
    to_return[[s]]<-x
  }
  return(bind_rows(original,to_return))
}

indat<-datday %>% ungroup() %>% mutate(Index=1:nrow(.)) %>% group_by(Index) %>% do(fill_species(.)) %>% select(-Index)
```

#Models

```{r}
models<-list()
chains<-list()
networks<-list()
```

## Random Baseline

```{r}
indat$jinterval<-as.numeric(indat$interval)

#Easiest to work with jags as numeric ordinal values
indat$Hummingbird<-as.factor(indat$Hummingbird)
indat$Iplant_Double<-as.factor(indat$Iplant_Double)
indat$jBird<-as.numeric(indat$Hummingbird)
indat$jPlant<-as.numeric(indat$Iplant_Double)
indat$jinterval<-as.numeric(indat$interval)

jagsIndexBird<-data.frame(Hummingbird=levels(indat$Hummingbird),jBird=1:length(levels(indat$Hummingbird)))

jagsIndexPlants<-data.frame(Iplant_Double=levels(indat$Iplant_Double),jPlant=1:length(levels(indat$Iplant_Double)))

#Similiarly, the trait matrix needs to reflect this indexing.
jTraitmatch<-traitmatch[rownames(traitmatch) %in% unique(indat$Hummingbird),colnames(traitmatch) %in% unique(indat$Iplant_Double)]

indat$Index<-1:nrow(indat)
indat<-droplevels(indat)

#Turn Time and ID into numeric indexes
indat$jTime<-as.numeric(as.factor(indat$Date))
indat$jID<-as.numeric(as.factor(indat$ID))

#Split data
split_dat<-split(indat,indat$interval)
Yobs_dat<-split_dat[[1]]
Ynew_dat<-split_dat[[2]]
```

$$ Yobs_{i,j} \sim Bernoulli(N(0,1.68)) $$

Note that this is a random probability of interaction on a per observation basis. This is different than a random link model. If we are interested in a binary network, a random interaction probability model will lead to a link probability of 1-(1/2)^n in n sampling events.

```{r}
#Source model
source("models/SpeciesIdentity.R")

#print model
writeLines(readLines("models/SpeciesIdentity.R"))
```

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    Ynew_pred<-rep(1,Dat$Nnewdata)
    list(Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew","Enew")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Birds=max(c(Yobs_dat$jBird,Ynew_dat$jPlant)),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(c(Yobs_dat$jPlant,Ynew_dat$jPlant)),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity.jags",n.thin=1,n.iter=2000,n.burnin=1900,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Random<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
  splitpc[c("Ynew_pred","Enew")]<-lapply(
    splitpc[c("Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}
#generate chains
chains$Random<-getChains(models$Random)

##Generate network
networks$Random<-getPredictions(pars=chains$Random,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=5,fig.height=2}
###Chains
chains$Random %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

## Species Identity

$$ Yobs_{i,j} \sim Bernoulli(\lambda_{i,j}) $$

```{r}
#Source model
source("models/SpeciesIdentity.R")

#print model
writeLines(readLines("models/SpeciesIdentity.R"))
```

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    Ynew_pred<-rep(1,Dat$Nnewdata)
    list(Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew","Enew")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(c(Yobs_dat$jBird,Ynew_dat$jPlant)),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(c(Yobs_dat$jPlant,Ynew_dat$jPlant)),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity.jags",n.thin=1,n.iter=2000,n.burnin=1900,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Species<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
  splitpc[c("Ynew_pred","Enew")]<-lapply(
    splitpc[c("Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}

##Generate chains
chains$Species<-getChains(models$Species)

##Generate networks
networks$Species<-getPredictions(chains$Species,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=5,fig.height=2}
###Chains
chains$Species %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

## Trait-matching

For hummingbird species i feeding on plant species j observed at time k and sampling event observed by transect 

Observation Model:

$$ Yobs_{i,j,k,d} \sim Binomial(N_{i,j,k},\omega) $$

Process Model:

$$ N_{i,j,k} \sim Binomial(\lambda_{i,j,k}) $$
$$ logit(\lambda_{i,j,k}) = \alpha_i + \beta_{1,i} * Traitmatch_{i,j} $$

```{r}
#Source model
source("models/TraitMatch.R")

#print model
writeLines(readLines("models/TraitMatch.R"))

runModel<-function(Yobs_dat,Ynew_dat,jTraitmatch){
  
  #Inits
  InitStage <- function(){
    #A blank Y matrix - all present
    Ynew_pred<-rep(1,Dat$Nnewdata)
    list(Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","beta1","alpha_mu","alpha_sigma","beta1_sigma","beta1_mu","Ynew_pred","fit","fitnew","Enew")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(c(Yobs_dat$jBird,Ynew_dat$jPlant)),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew),
    Traitmatch=jTraitmatch)
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/TraitMatch.jags",n.thin=1,n.iter=2000,n.burnin=1900,n.chains=2,DIC=F)
    )
    return(m2)
}

#Run Model
models$Traits<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat,jTraitmatch=jTraitmatch)
```

```{r}
getChains<-function(x,Bird="Bird",Plant="Plant"){
  #extract desired info from the models
  #bind chains
  pc_dive<-reshape2::melt(x$BUGSoutput$sims.array)
  colnames(pc_dive)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc_dive$parameter<-data.frame(str_match(pc_dive$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc_dive,pc_dive$parameter)
  
  #single index
  splitpc[c("alpha","beta1","Ynew_pred","Enew")]<-lapply(splitpc[c("alpha","beta1","Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    return(pc)
  }) 
  
  #bind all matrices back together
  pc_dive<-bind_rows(splitpc)
}
```

```{r}
#Get Chains
chains$Traits<-getChains(models$Traits,Bird="jBird",Plant="jPlant")

#Get networks
networks$Traits<-getPredictions(chains$Traits,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=13,fig.height=5}
###Chains
ggplot(chains$Traits[chains$Traits$parameter %in% c("alpha_mu","beta1_mu"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~parameter,scale="free") + theme_bw() + labs(col="Chain") 
```

```{r,fig.height=5,fig.width=11}
ggplot(chains$Traits[chains$Traits$par %in% c("beta1_mu","beta1_sigma","alpha_mu","alpha_sigma"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Group Level Parameters") + facet_wrap(~par,scales="free")
```

# Detectability

To Do. Should I also do traits without the detection probabilities?

## Species Identity
Observation Model:

$$ Yobs_{i,j,k,d} \sim Binomial(N_{i,j,k},\omega) $$

Process Model:

$$ N_{i,j,k} \sim Binomial(\lambda_{i,j}) $$
$$ Yobs_{i,j} \sim Bernoulli(\lambda_{i,j}) $$

```{r}
#Source model
source("models/SpeciesIdentity_Detect.R")

#print model
writeLines(readLines("models/SpeciesIdentity_Detect.R"))
```

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    #A blank Y matrix - all present
    initY<-rep(1,Dat$Nobs)
    initB<-rep(0.5,Dat$Birds)
    Ynew_pred<-rep(1,Dat$Nnewdata)
    z<-rep(1,Dat$Nobs)
    znew<-rep(1,Dat$Nnewdata)
    
    list(dcam=initB,znew=znew,z=z,Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew","Enew","detect")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(c(Yobs_dat$jBird,Ynew_dat$jPlant)),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(c(Yobs_dat$jPlant,Ynew_dat$jPlant)),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity_Detect.jags",n.thin=1,n.iter=2000,n.burnin=1900,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Species_Detect<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
  splitpc[c("Ynew_pred","Enew","detect")]<-lapply(
    splitpc[c("Ynew_pred","Enew","detect")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}

##Generate chains
chains$Species_Detect<-getChains(models$Species_Detect)

##Generate networks
networks$Species_Detect<-getPredictions(chains$Species_Detect,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=5,fig.height=2}
###Chains
chains$Species_Detect %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

## Trait-matching

For hummingbird species i feeding on plant species j observed at time k and sampling event observed by transect 

Observation Model:

$$ Yobs_{i,j,k,d} \sim Binomial(N_{i,j,k},\omega) $$

Process Model:

$$ N_{i,j,k} \sim Binomial(\lambda_{i,j,k}) $$
$$ logit(\lambda_{i,j,k}) = \alpha_i + \beta_{1,i} * Traitmatch_{i,j} $$

```{r}
#Source model
source("models/TraitMatch_Detect.R")

#print model
writeLines(readLines("models/TraitMatch_Detect.R"))

runModel<-function(Yobs_dat,Ynew_dat,jTraitmatch){
  
  #Inits
  InitStage <- function(){
    #A blank Y matrix - all present
    initY<-rep(1,Dat$Nobs)
    initB<-rep(0.5,Dat$Birds)
    Ynew_pred<-rep(1,Dat$Nnewdata)
    z<-rep(1,Dat$Nobs)
    znew<-rep(1,Dat$Nnewdata)
    
    list(dcam=initB,znew=znew,z=z,Ynew_pred=Ynew_pred)}
  
  #Parameters to track
  ParsStage <- c("alpha","beta1","alpha_mu","alpha_sigma","beta1_sigma","beta1_mu","detect","Ynew_pred","fit","fitnew","Enew")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(c(Yobs_dat$jBird,Ynew_dat$jPlant)),
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew),
    Traitmatch=jTraitmatch)
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/TraitMatch_Detect.jags",n.thin=1,n.iter=2000,n.burnin=1900,n.chains=2,DIC=F)
    )
    return(m2)
}

#Run Model
models$Traits_Detect<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat,jTraitmatch=jTraitmatch)
```

```{r}
getChains<-function(x,Bird="Bird",Plant="Plant"){
  #extract desired info from the models
  #bind chains
  pc_dive<-reshape2::melt(x$BUGSoutput$sims.array)
  colnames(pc_dive)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc_dive$parameter<-data.frame(str_match(pc_dive$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc_dive,pc_dive$parameter)
  
  #single index
  splitpc[c("alpha","beta1","detect","Ynew_pred","Enew")]<-lapply(splitpc[c("alpha","beta1","detect","Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    return(pc)
  }) 
  
  #bind all matrices back together
  pc_dive<-bind_rows(splitpc)
}
```

```{r}
#Get Chains
chains$Traits_Detect<-getChains(models$Traits_Detect,Bird="jBird",Plant="jPlant")

#Get networks
networks$Traits_Detect<-getPredictions(chains$Traits_Detect,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=13,fig.height=5}
###Chains
ggplot(chains$Traits_Detect[chains$Traits_Detect$parameter %in% c("alpha_mu","beta1_mu"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~parameter,scale="free") + theme_bw() + labs(col="Chain") 
```

```{r,fig.height=5,fig.width=11}
ggplot(chains$Traits_Detect[chains$Traits_Detect$par %in% c("beta1_mu","beta1_sigma","alpha_mu","alpha_sigma"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + theme_bw() + labs(col="Chain") + ggtitle("Group Level Parameters") + facet_wrap(~par,scales="free")
```

## Abundance 

Using the counts from the transects. Abundance is especially important to model, since its fluctuating all the time.

Do we have time for this?

# Incorportating species occurrence 

If species co-occurrence is a prerequisite for interaction, then the absence of interactions may stem either from a lack of detectability or species absence. We can jointly model the presence of species as a function of elevation and then existance of an interaction.

## Species Identity
Observation Model:

$$ Yobs_{i,j,k,d} \sim Binomial(N_{i,j,k},\omega) $$

Process Model:

$$ N_{i,j,k} \sim Binomial(\lambda_{i,j}) $$
$$ Yobs_{i,j} \sim Bernoulli(\lambda_{i,j}) $$

```{r}
#Source model
source("models/SpeciesIdentity_Detect_Elevation.R")

#print model
writeLines(readLines("models/SpeciesIdentity_Detect_Elevation.R"))
```

```{r}
#Run Model
runModel<-function(Yobs_dat,Ynew_dat){
  
  #Inits
  InitStage <- function(){
    #A blank Y matrix - all present
    initY<-rep(1,Dat$Nobs)
    initB<-rep(0.5,Dat$Birds)
    Ynew_pred<-rep(1,Dat$Nnewdata)
    z<-rep(1,Dat$Nobs)
    znew<-rep(1,Dat$Nnewdata)
    occ_new<-rep(1,Dat$Nnewdata)
    occ<-rep(1,Dat$Nobs)
    
    list(dcam=initB,znew=znew,z=z,Ynew_pred=Ynew_pred,occ_new=occ_new,occ=occ)}
  
  #Parameters to track
  ParsStage <- c("alpha","Ynew_pred","fit","fitnew","Enew","alpha_occ","beta_occ","beta2_occ")
  
  #Jags Data
  Yobs<-Yobs_dat$Yobs
  Ynew<-Ynew_dat$Yobs
  
  Dat<-list(
    Yobs=Yobs,
    Birds=max(c(Yobs_dat$jBird,Ynew_dat$jPlant)),
    elevation=Yobs_dat$ele,
    elevation_new=Ynew_dat$ele,
    Bird=Yobs_dat$jBird,
    Plant=Yobs_dat$jPlant,
    Plants=max(c(Yobs_dat$jPlant,Ynew_dat$jPlant)),
    Nobs=length(Yobs),
    NewBird=Ynew_dat$jBird,
    NewPlant=Ynew_dat$jPlant,
    Ynew=Ynew,
    Nnewdata=length(Ynew))
  
  #MCMC options
    system.time(
      m2<-jags(data=Dat,parameters.to.save=ParsStage,inits=InitStage,model.file="models/SpeciesIdentity_Detect_Elevation.jags",n.thin=1,n.iter=2000,n.burnin=1900,n.chains=2,DIC=F)
    )
    return(m2)
}

models$Species_Detect_Elevation<-runModel(Yobs_dat=Yobs_dat,Ynew_dat=Ynew_dat)
```

```{r}
#Get Chains
getChains<-function(mod){
  
  pc<-reshape2::melt(mod$BUGSoutput$sims.array)
  colnames(pc)<-c("Draw","chain","par","value")
  
  #extract parameter name
  pc$parameter<-data.frame(str_match(pc$par,"(\\w+)"))[,-1]
  
  #Extract index
  splitpc<-split(pc,pc$parameter)
  
  #single index
  splitpc[c("alpha")]<-lapply(
    splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+)]"))[,3:4]
    colnames(sv)<-c("jBird","jPlant")
    pc<-data.frame(x,sv)
    })
  
    splitpc[c("alpha_occ","beta_occ","beta2_occ")]<-lapply(
    splitpc[c("alpha_occ","beta_occ","beta2_occ")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,jBird=sv)
    })
  
  splitpc[c("Ynew_pred","Enew")]<-lapply(
    splitpc[c("Ynew_pred","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Index=sv)
    })
    
  chains<-bind_rows(splitpc)
return(chains)}
```

```{r}

##Generate chains
chains$Species_Detect_Elevation<-getChains(models$Species_Detect_Elevation)

##Generate networks
networks$Species_Detect_Elevation<-getPredictions(chains$Species_Detect_Elevation,Ynew_dat = Ynew_dat)
```

###Assess Convergence

```{r,cache=FALSE,fig.width=5,fig.height=2}
###Chains
chains$Species_Detect_Elevation %>% filter(parameter == "fitnew")  %>% ggplot(.,aes(x=Draw,y=value,col=as.factor(chain))) + geom_line()  + theme_bw() + labs(col="Chain") + facet_wrap(~parameter)
```

### Elevation ranges

```{r}
elev_sim<-function(Model,jBird,alpha,beta,beta2,elevation){
  p<-inv.logit(alpha+beta*elevation+beta2*elevation^2)
  data.frame(Model=Model,jBird=jBird,elevation=elevation,p=p)
}

bird_range <- chains$Species_Detect_Elevation %>% filter(parameter %in% c("alpha_occ","beta_occ","beta2_occ")) %>% select(-par) %>% spread(parameter,value) %>% group_by(Model,jBird,Draw,chain) %>% do(elev_sim(Model=.$Model,.$jBird,.$alpha_occ,.$beta_occ,.$beta2_occ,elevation=unique(Ynew_dat$ele))) %>% mutate(jBird=as.numeric(as.character(jBird))) %>% inner_join(jagsIndexBird) %>% group_by(Model,Hummingbird,elevation) %>% dplyr::summarise(mean=mean(p),lower=quantile(p,0.05),upper=quantile(p,0.95))
 
ggplot(bird_range,aes(x=elevation))  + geom_line(aes(y=mean)) + geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.2) + facet_wrap(~Hummingbird) + labs(x="Elevation",y="Probability of Occurrence")
```

# Model Comparison

```{r,fig.height=7,fig.width=8}
#A bit ugly, but let's assign names.
for(x in 1:length(chains)){
    chains[[x]]<-chains[[x]] %>% mutate(Model=names(chains)[x])
  }

allchains<-bind_rows(lapply(chains,bind_rows))

Ynew_dat$Index<-1:nrow(Ynew_dat)

fitnew<-allchains %>% filter(parameter=="Enew")  %>% mutate(Level=str_extract(Model,"_(\\w+)")) %>% group_by(Model) %>% mutate(Index=as.numeric(Index)) %>% select(Model,Level,Draw,chain,Index,value) %>% inner_join(Ynew_dat,by="Index") %>% separate(Model,sep="_",c("Model","Detect","Elevation")) %>% select(-Detect,-Elevation)  %>% group_by(Model,Level,Draw,chain,Yobs) %>% dplyr::summarize(p=sum(value)/n())

fitnew$Level[is.na(fitnew$Level)]<-""
fitnew$Level<-as.factor(fitnew$Level)
levels(fitnew$Level)<-c("","+Detect","+Detect +Elevation")

fitnew$Yobs<-factor(fitnew$Yobs)
levels(fitnew$Yobs)<-c("Absences","Presences")

ggplot(fitnew,aes(x=1-p,fill=Model)) + theme_bw() + labs(x="Proportion of correctly predicted observations") + scale_x_continuous(labels=scales::percent) + facet_grid(Level~Yobs,scales="free")  + geom_density(alpha=0.3) 

#ggsave("Figures/PredLinksBoth.svg")
#ggsave("Figures/PredLinksBoth.jpeg",height=3,width=7)
```

## Predicted network statistics

Dashed line is the observed network from the time-series.

```{r,fig.height=7,fig.width=10}

#How many presences?
netdf<-melt(networks)
netdf %>% group_by(L1,value,L2) %>% dplyr::summarize(n=n()) %>% group_by(L1,value) %>% dplyr::summarize(n=mean(n))

#Get network statistics for all models.
allnetworks<-lapply(networks,function(x){
    lapply(x,function(y){
      d<-networklevel(y,index=c("connectance","niche overlap"),level="lower")
      return(data.frame(Metric=names(d),value=d))
    })
  })
allnetworks<-melt(allnetworks,id.var=c("Metric","value"))

#Observed binary network
m_new<-acast(Ynew_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)
m_new<-m_new > 0 * 1
obs_net<-networklevel(m_new,index=c("connectance","niche overlap"),level="lower")
obs_net<-melt(data.frame(Metric=names(obs_net),value=obs_net))

#Plot
allnetworks<-allnetworks %>% select(Model=L1,Metric,value) %>% mutate(Level=str_extract(Model,"_(\\w+)"))%>% separate(Model,sep="_",c("Model","Detect","Elevation")) %>% select(-Detect,-Elevation) 

allnetworks$Level[is.na(allnetworks$Level)]<-""
allnetworks$Level<-as.factor(allnetworks$Level)
levels(allnetworks$Level)<-c("","+Detect","+Detect +Elevation")

ggplot(allnetworks,aes(x=value)) + geom_density(aes(fill=Model),alpha=0.5) + facet_grid(Level~Metric) + geom_vline(data=obs_net,aes(xintercept=value),linetype="dashed") + theme_bw()
```

# Predicted betadiversity

Dissimilairty in interactions (Beta_WN from Poisot 2012)
Dashed line is the observed network from the time-series.

```{r}
#Observed dissimalarity
m_obs<-acast(Yobs_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)
m_new<-acast(Ynew_dat,Hummingbird~Iplant_Double,value.var="Yobs",fun.aggregate = sum)

#Turn into binary links
m_obs<-m_obs > 0 * 1
m_new<-m_new > 0 * 1

obs_dis<-betalink(graph.incidence(m_obs),graph.incidence(m_new))
```

```{r,fig.height=8,fig.width=10}
betastat<-lapply(networks,function(x){
  lapply(x,function(y){
    obs_dis<-betalink(graph.incidence(m_obs),graph.incidence(y))
  })
})

betastat<-melt(betastat)
colnames(betastat)<-c("value","Betadiversity","Iteration","Model")

#label models
betastat<-betastat %>% mutate(Level=str_extract(Model,"_(\\w+)"))%>% separate(Model,sep="_",c("Model","Detect","Elevation")) %>% select(-Detect,-Elevation) 

betastat$Level[is.na(betastat$Level)]<-""
betastat$Level<-as.factor(betastat$Level)
levels(betastat$Level)<-c("","+Detect","+Detect +Elevation")

#Observed dis.
mobs_dis<-melt(obs_dis)
colnames(mobs_dis)<-c("value","Betadiversity")

#recode levels to make more attractice.
betastat$Betadiversity<-factor(betastat$Betadiversity)
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "WN"]<-"Interaction Dissimilarity"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "ST"]<-"Interaction Turnover"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "OS"]<-"Interaction Rewiring"
levels(betastat$Betadiversity)[levels(betastat$Betadiversity) %in% "S"]<-"Species Turnover"

mobs_dis$Betadiversity<-factor(mobs_dis$Betadiversity)
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "WN"]<-"Interaction Dissimilarity"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "ST"]<-"Interaction Turnover"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "OS"]<-"Interaction Rewiring"
levels(mobs_dis$Betadiversity)[levels(mobs_dis$Betadiversity) %in% "S"]<-"Species Turnover"

ggplot(betastat %>% filter(!Betadiversity %in% "Species Turnover"),aes(x=value,fill=Model)) + geom_density() + facet_grid(Level~Betadiversity,scales="free") + geom_vline(data=mobs_dis  %>% filter(!Betadiversity %in% "Species Turnover"),aes(xintercept=value),linetype="dashed")
```

# Model overlap

Create a kind of venn diagram on PCA of model similarity based on per link discrepency. 

```{r}
Enew<-allchains %>% filter(parameter == "Enew") %>% mutate(Index=as.numeric(as.character(Index)))

worst<-Ynew_dat %>% dplyr::select(-jinterval,-interval) %>% mutate(Index=1:nrow(Ynew_dat)) %>% inner_join(Enew,by="Index")%>% dplyr::group_by(Model,Hummingbird,Iplant_Double) %>% dplyr::summarize(mean=mean(-1*value,na.rm=T)) %>% mutate(pair=paste(Hummingbird,Iplant_Double,sep="_")) %>% ungroup() %>% dplyr::select(-Hummingbird,-Iplant_Double) %>% arrange(mean) %>% group_by(Model) %>% top_n(-4,mean) 

worst

Enew<-Ynew_dat %>% dplyr::select(-jinterval,-interval) %>% mutate(Index=1:nrow(Ynew_dat)) %>% inner_join(Enew,by="Index")%>% dplyr::group_by(Model,Hummingbird,Iplant_Double) %>% dplyr::summarize(mean=mean(-1*value,na.rm=T)) %>% mutate(pair=paste(Hummingbird,Iplant_Double,sep="_")) %>% ungroup() %>% dplyr::select(-Hummingbird,-Iplant_Double) %>% spread(pair,mean) 

modmatrix<-t(Enew[,-1])
colnames(modmatrix)<-Enew[,1]$Model
prmodel<-prcomp(modmatrix,scale=T)

#get best differntial labels, those which exist in the edges of the space
#loadings<-melt(prmodel$x) %>% spread(Var2,value) %>% group_by(Var2) %>% dplyr::summarize(min(value),max(value))

ggbiplot(prmodel,alpha=0.2,varname.size = 4) + theme_bw() 
```

```{r}
save.image("ObservedModel.RData")
```